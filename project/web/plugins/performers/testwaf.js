"use strict";
var WAFMIDIPresetURLs = [];
WAFMIDIPresetURLs[1] = "0000_JCLive_sf2_file";
WAFMIDIPresetURLs[2] = "0010_Aspirin_sf2_file";
WAFMIDIPresetURLs[3] = "0020_Aspirin_sf2_file";
WAFMIDIPresetURLs[4] = "0030_Aspirin_sf2_file";
WAFMIDIPresetURLs[5] = "0040_Aspirin_sf2_file";
WAFMIDIPresetURLs[6] = "0050_Aspirin_sf2_file";
WAFMIDIPresetURLs[7] = "0060_Aspirin_sf2_file";
WAFMIDIPresetURLs[8] = "0070_Aspirin_sf2_file";
WAFMIDIPresetURLs[9] = "0080_Aspirin_sf2_file";
WAFMIDIPresetURLs[10] = "0090_Aspirin_sf2_file";
WAFMIDIPresetURLs[11] = "0100_Aspirin_sf2_file";
WAFMIDIPresetURLs[12] = "0110_Aspirin_sf2_file";
WAFMIDIPresetURLs[13] = "0120_Aspirin_sf2_file";
WAFMIDIPresetURLs[14] = "0130_Aspirin_sf2_file";
WAFMIDIPresetURLs[15] = "0140_Aspirin_sf2_file";
WAFMIDIPresetURLs[16] = "0150_Aspirin_sf2_file";
WAFMIDIPresetURLs[17] = "0160_Aspirin_sf2_file";
WAFMIDIPresetURLs[18] = "0170_Aspirin_sf2_file";
WAFMIDIPresetURLs[19] = "0180_Aspirin_sf2_file";
WAFMIDIPresetURLs[20] = "0190_Aspirin_sf2_file";
WAFMIDIPresetURLs[21] = "0200_Aspirin_sf2_file";
WAFMIDIPresetURLs[22] = "0210_Aspirin_sf2_file";
WAFMIDIPresetURLs[23] = "0220_Aspirin_sf2_file";
WAFMIDIPresetURLs[24] = "0230_Aspirin_sf2_file";
WAFMIDIPresetURLs[25] = "0240_Aspirin_sf2_file";
WAFMIDIPresetURLs[26] = "0253_Acoustic_Guitar_sf2_file";
WAFMIDIPresetURLs[27] = "0260_Aspirin_sf2_file";
WAFMIDIPresetURLs[28] = "0270_Aspirin_sf2_file";
WAFMIDIPresetURLs[29] = "0280_Aspirin_sf2_file";
WAFMIDIPresetURLs[30] = "0290_Aspirin_sf2_file";
WAFMIDIPresetURLs[31] = "0300_Aspirin_sf2_file";
WAFMIDIPresetURLs[32] = "0310_Aspirin_sf2_file";
WAFMIDIPresetURLs[33] = "0320_Aspirin_sf2_file";
WAFMIDIPresetURLs[34] = "0330_Aspirin_sf2_file";
WAFMIDIPresetURLs[35] = "0340_Aspirin_sf2_file";
WAFMIDIPresetURLs[36] = "0350_Aspirin_sf2_file";
WAFMIDIPresetURLs[37] = "0360_Aspirin_sf2_file";
WAFMIDIPresetURLs[38] = "0370_Aspirin_sf2_file";
WAFMIDIPresetURLs[39] = "0385_GeneralUserGS_sf2_file";
WAFMIDIPresetURLs[40] = "0390_Aspirin_sf2_file";
WAFMIDIPresetURLs[41] = "0400_Aspirin_sf2_file";
WAFMIDIPresetURLs[42] = "0410_Aspirin_sf2_file";
WAFMIDIPresetURLs[43] = "0420_Aspirin_sf2_file";
WAFMIDIPresetURLs[44] = "0430_Aspirin_sf2_file";
WAFMIDIPresetURLs[45] = "0440_Aspirin_sf2_file";
WAFMIDIPresetURLs[46] = "0450_Aspirin_sf2_file";
WAFMIDIPresetURLs[47] = "0460_Aspirin_sf2_file";
WAFMIDIPresetURLs[48] = "0470_Aspirin_sf2_file";
WAFMIDIPresetURLs[49] = "0480_Aspirin_sf2_file";
WAFMIDIPresetURLs[50] = "0490_Aspirin_sf2_file";
WAFMIDIPresetURLs[51] = "0500_Aspirin_sf2_file";
WAFMIDIPresetURLs[52] = "0510_Aspirin_sf2_file";
WAFMIDIPresetURLs[53] = "0520_Aspirin_sf2_file";
WAFMIDIPresetURLs[54] = "0530_Aspirin_sf2_file";
WAFMIDIPresetURLs[55] = "0540_Aspirin_sf2_file";
WAFMIDIPresetURLs[56] = "0550_Aspirin_sf2_file";
WAFMIDIPresetURLs[57] = "0560_Aspirin_sf2_file";
WAFMIDIPresetURLs[58] = "0570_Aspirin_sf2_file";
WAFMIDIPresetURLs[59] = "0580_Aspirin_sf2_file";
WAFMIDIPresetURLs[60] = "0590_Aspirin_sf2_file";
WAFMIDIPresetURLs[61] = "0600_Aspirin_sf2_file";
WAFMIDIPresetURLs[62] = "0610_Aspirin_sf2_file";
WAFMIDIPresetURLs[63] = "0620_Aspirin_sf2_file";
WAFMIDIPresetURLs[64] = "0630_Aspirin_sf2_file";
WAFMIDIPresetURLs[65] = "0640_Aspirin_sf2_file";
WAFMIDIPresetURLs[66] = "0650_Aspirin_sf2_file";
WAFMIDIPresetURLs[67] = "0660_Aspirin_sf2_file";
WAFMIDIPresetURLs[68] = "0670_Aspirin_sf2_file";
WAFMIDIPresetURLs[69] = "0680_Aspirin_sf2_file";
WAFMIDIPresetURLs[70] = "0690_Aspirin_sf2_file";
WAFMIDIPresetURLs[71] = "0700_Aspirin_sf2_file";
WAFMIDIPresetURLs[72] = "0710_Aspirin_sf2_file";
WAFMIDIPresetURLs[73] = "0720_Aspirin_sf2_file";
WAFMIDIPresetURLs[74] = "0730_Aspirin_sf2_file";
WAFMIDIPresetURLs[75] = "0740_Aspirin_sf2_file";
WAFMIDIPresetURLs[76] = "0750_Aspirin_sf2_file";
WAFMIDIPresetURLs[77] = "0760_Aspirin_sf2_file";
WAFMIDIPresetURLs[78] = "0770_Aspirin_sf2_file";
WAFMIDIPresetURLs[79] = "0780_Aspirin_sf2_file";
WAFMIDIPresetURLs[80] = "0790_Aspirin_sf2_file";
WAFMIDIPresetURLs[81] = "0800_Aspirin_sf2_file";
WAFMIDIPresetURLs[82] = "0810_Aspirin_sf2_file";
WAFMIDIPresetURLs[83] = "0820_Aspirin_sf2_file";
WAFMIDIPresetURLs[84] = "0830_Aspirin_sf2_file";
WAFMIDIPresetURLs[85] = "0840_Aspirin_sf2_file";
WAFMIDIPresetURLs[86] = "0850_Aspirin_sf2_file";
WAFMIDIPresetURLs[87] = "0860_Aspirin_sf2_file";
WAFMIDIPresetURLs[88] = "0870_Aspirin_sf2_file";
WAFMIDIPresetURLs[89] = "0880_Aspirin_sf2_file";
WAFMIDIPresetURLs[90] = "0890_Aspirin_sf2_file";
WAFMIDIPresetURLs[91] = "0900_Aspirin_sf2_file";
WAFMIDIPresetURLs[92] = "0910_Aspirin_sf2_file";
WAFMIDIPresetURLs[93] = "0920_Aspirin_sf2_file";
WAFMIDIPresetURLs[94] = "0930_Aspirin_sf2_file";
WAFMIDIPresetURLs[95] = "0940_Aspirin_sf2_file";
WAFMIDIPresetURLs[96] = "0950_Aspirin_sf2_file";
WAFMIDIPresetURLs[97] = "0960_Aspirin_sf2_file";
WAFMIDIPresetURLs[98] = "0970_Aspirin_sf2_file";
WAFMIDIPresetURLs[99] = "0980_Aspirin_sf2_file";
WAFMIDIPresetURLs[100] = "0990_Aspirin_sf2_file";
WAFMIDIPresetURLs[101] = "1000_Aspirin_sf2_file";
WAFMIDIPresetURLs[102] = "1010_Aspirin_sf2_file";
WAFMIDIPresetURLs[103] = "1020_Aspirin_sf2_file";
WAFMIDIPresetURLs[104] = "1030_Aspirin_sf2_file";
WAFMIDIPresetURLs[105] = "1040_Aspirin_sf2_file";
WAFMIDIPresetURLs[106] = "1050_Aspirin_sf2_file";
WAFMIDIPresetURLs[107] = "1060_Aspirin_sf2_file";
WAFMIDIPresetURLs[108] = "1070_Aspirin_sf2_file";
WAFMIDIPresetURLs[109] = "1080_Aspirin_sf2_file";
WAFMIDIPresetURLs[110] = "1090_Aspirin_sf2_file";
WAFMIDIPresetURLs[111] = "1100_Aspirin_sf2_file";
WAFMIDIPresetURLs[112] = "1110_Aspirin_sf2_file";
WAFMIDIPresetURLs[113] = "1120_Aspirin_sf2_file";
WAFMIDIPresetURLs[114] = "1130_Aspirin_sf2_file";
WAFMIDIPresetURLs[115] = "1140_Aspirin_sf2_file";
WAFMIDIPresetURLs[116] = "1150_Aspirin_sf2_file";
WAFMIDIPresetURLs[117] = "1160_Aspirin_sf2_file";
WAFMIDIPresetURLs[118] = "1170_Aspirin_sf2_file";
WAFMIDIPresetURLs[119] = "1180_Aspirin_sf2_file";
WAFMIDIPresetURLs[120] = "1190_Aspirin_sf2_file";
WAFMIDIPresetURLs[121] = "1200_Aspirin_sf2_file";
WAFMIDIPresetURLs[122] = "1210_Aspirin_sf2_file";
WAFMIDIPresetURLs[123] = "1220_Aspirin_sf2_file";
WAFMIDIPresetURLs[124] = "1230_Aspirin_sf2_file";
WAFMIDIPresetURLs[125] = "1240_Aspirin_sf2_file";
WAFMIDIPresetURLs[126] = "1250_Aspirin_sf2_file";
WAFMIDIPresetURLs[127] = "1260_Aspirin_sf2_file";
WAFMIDIPresetURLs[128] = "1270_Aspirin_sf2_file";
class PerformerPluginWAF {
    constructor() {
        this.midiProgram = -1;
        this.instrumentKeyArray = [];
        this.instrumentNamesArray = [];
        this.envelopes = [];
        this.afterTime = 0.05;
        this.nearZero = 0.000001;
    }
    launch(context, parameters) {
        if (this.out) {
        }
        else {
            this.audioContext = context;
            this.out = this.audioContext.createGain();
        }
        let nn = parseInt(parameters);
        if (this.midiProgram == nn) {
        }
        else {
            this.midiProgram = nn;
            this.startLoadPreset(this.midiProgram);
        }
    }
    schedule(when, pitch, slides) {
        let info = this.instrumentInfo(this.midiProgram);
        let preset = window[info.variable];
        let rr = this.queueWaveTable(this.out, preset, when, pitch, slides);
    }
    output() {
        return this.out;
    }
    cancel() {
        this.cancelQueue();
    }
    busy() {
        if (this.presetReady(this.midiProgram)) {
            return null;
        }
        else {
            return 'program ' + this.midiProgram + ' isn\'t ready';
        }
    }
    startLoadPreset(nn) {
        let info = this.instrumentInfo(nn);
        let me = this;
        if (MZXBX_appendScriptURL(info.url)) {
            MZXBX_waitForCondition(250, () => { return (window[info.variable]); }, () => {
                let preset = window[info.variable];
                me.adjustPreset(preset);
            });
        }
    }
    presetReady(nn) {
        let info = this.instrumentInfo(nn);
        let loaded = window[info.variable];
        if (loaded) {
            let preset = loaded;
            for (var i = 0; i < preset.zones.length; i++) {
                if (preset.zones[i].buffer) {
                }
                else {
                    return false;
                }
            }
            return true;
        }
        else {
            return false;
        }
    }
    adjustPreset(preset) {
        for (var i = 0; i < preset.zones.length; i++) {
            this.adjustZone(preset.zones[i]);
        }
    }
    ;
    adjustZone(zone) {
        if (zone.buffer) {
        }
        else {
            zone.delay = 0;
            if (zone.sample) {
                var decoded = atob(zone.sample);
                zone.buffer = this.audioContext.createBuffer(1, decoded.length / 2, zone.sampleRate);
                var float32Array = zone.buffer.getChannelData(0);
                var b1, b2, n;
                for (var i = 0; i < decoded.length / 2; i++) {
                    b1 = decoded.charCodeAt(i * 2);
                    b2 = decoded.charCodeAt(i * 2 + 1);
                    if (b1 < 0) {
                        b1 = 256 + b1;
                    }
                    if (b2 < 0) {
                        b2 = 256 + b2;
                    }
                    n = b2 * 256 + b1;
                    if (n >= 65536 / 2) {
                        n = n - 65536;
                    }
                    float32Array[i] = n / 65536.0;
                }
            }
            else {
                if (zone.file) {
                    var datalen = zone.file.length;
                    var arraybuffer = new ArrayBuffer(datalen);
                    var view = new Uint8Array(arraybuffer);
                    var decoded = atob(zone.file);
                    var b;
                    for (var i = 0; i < decoded.length; i++) {
                        b = decoded.charCodeAt(i);
                        view[i] = b;
                    }
                    this.audioContext.decodeAudioData(arraybuffer, function (audioBuffer) {
                        zone.buffer = audioBuffer;
                    });
                }
            }
            zone.loopStart = this.numValue(zone.loopStart, 0);
            zone.loopEnd = this.numValue(zone.loopEnd, 0);
            zone.coarseTune = this.numValue(zone.coarseTune, 0);
            zone.fineTune = this.numValue(zone.fineTune, 0);
            zone.originalPitch = this.numValue(zone.originalPitch, 6000);
            zone.sampleRate = this.numValue(zone.sampleRate, 44100);
            zone.sustain = this.numValue(zone.originalPitch, 0);
        }
    }
    ;
    numValue(aValue, defValue) {
        if (typeof aValue === "number") {
            return aValue;
        }
        else {
            return defValue;
        }
    }
    ;
    findZone(audioContext, preset, pitch) {
        var zone = null;
        for (var i = preset.zones.length - 1; i >= 0; i--) {
            zone = preset.zones[i];
            if (zone.keyRangeLow <= pitch && zone.keyRangeHigh + 1 >= pitch) {
                break;
            }
        }
        return zone;
    }
    ;
    findEnvelope(audioContext, out) {
        var envelope = null;
        for (var i = 0; i < this.envelopes.length; i++) {
            var e = this.envelopes[i];
            if (e.out == out && audioContext.currentTime > e.when + e.duration + 0.001) {
                try {
                    if (e.audioBufferSourceNode) {
                        e.audioBufferSourceNode.disconnect();
                        e.audioBufferSourceNode.stop(0);
                        e.audioBufferSourceNode = null;
                    }
                }
                catch (x) {
                }
                envelope = e;
                break;
            }
        }
        if (!(envelope)) {
            envelope = audioContext.createGain();
            envelope.out = out;
            envelope.connect(out);
            envelope.cancel = function () {
                if (envelope && (envelope.when + envelope.duration > audioContext.currentTime)) {
                    envelope.gain.cancelScheduledValues(0);
                    envelope.gain.setTargetAtTime(0.00001, audioContext.currentTime, 0.1);
                    envelope.when = audioContext.currentTime + 0.00001;
                    envelope.duration = 0;
                }
            };
            this.envelopes.push(envelope);
        }
        return envelope;
    }
    ;
    setupEnvelope(audioContext, envelope, zone, volume, when, sampleDuration, noteDuration) {
        envelope.gain.setValueAtTime(this.noZeroVolume(0), audioContext.currentTime);
        var lastTime = 0;
        var lastVolume = 0;
        var duration = noteDuration;
        var zoneahdsr = zone.ahdsr;
        if (sampleDuration < duration + this.afterTime) {
            duration = sampleDuration - this.afterTime;
        }
        if (zoneahdsr) {
            if (!(zoneahdsr.length > 0)) {
                zoneahdsr = [{
                        duration: 0,
                        volume: 1
                    }, {
                        duration: 0.5,
                        volume: 1
                    }, {
                        duration: 1.5,
                        volume: 0.5
                    }, {
                        duration: 3,
                        volume: 0
                    }
                ];
            }
        }
        else {
            zoneahdsr = [{
                    duration: 0,
                    volume: 1
                }, {
                    duration: duration,
                    volume: 1
                }
            ];
        }
        var ahdsr = zoneahdsr;
        envelope.gain.cancelScheduledValues(when);
        envelope.gain.setValueAtTime(this.noZeroVolume(ahdsr[0].volume * volume), when);
        for (var i = 0; i < ahdsr.length; i++) {
            if (ahdsr[i].duration > 0) {
                if (ahdsr[i].duration + lastTime > duration) {
                    var r = 1 - (ahdsr[i].duration + lastTime - duration) / ahdsr[i].duration;
                    var n = lastVolume - r * (lastVolume - ahdsr[i].volume);
                    envelope.gain.linearRampToValueAtTime(this.noZeroVolume(volume * n), when + duration);
                    break;
                }
                lastTime = lastTime + ahdsr[i].duration;
                lastVolume = ahdsr[i].volume;
                envelope.gain.linearRampToValueAtTime(this.noZeroVolume(volume * lastVolume), when + lastTime);
            }
        }
        envelope.gain.linearRampToValueAtTime(this.noZeroVolume(0), when + duration + this.afterTime);
    }
    ;
    noZeroVolume(n) {
        if (n > this.nearZero) {
            return n;
        }
        else {
            return this.nearZero;
        }
    }
    ;
    queueWaveTable(out, preset, when, pitch, slides) {
        let volume = 0.33;
        var zone = this.findZone(this.audioContext, preset, pitch);
        if (zone) {
            if (!(zone.buffer)) {
                console.log('empty buffer ', zone);
                return null;
            }
            var baseDetune = zone.originalPitch - 100.0 * zone.coarseTune - zone.fineTune;
            var playbackRate = 1.0 * Math.pow(2, (100.0 * pitch - baseDetune) / 1200.0);
            var startWhen = when;
            if (startWhen < this.audioContext.currentTime) {
                startWhen = this.audioContext.currentTime;
            }
            let noteDuration = 0;
            for (let i = 0; i < slides.length; i++) {
                noteDuration = noteDuration + slides[i].duration;
            }
            var waveDuration = noteDuration + this.afterTime;
            var loop = true;
            if (zone.loopStart < 1 || zone.loopStart >= zone.loopEnd) {
                loop = false;
            }
            if (!loop) {
                if (waveDuration > zone.buffer.duration / playbackRate) {
                    waveDuration = zone.buffer.duration / playbackRate;
                }
            }
            var envelope = this.findEnvelope(this.audioContext, out);
            this.setupEnvelope(this.audioContext, envelope, zone, volume, startWhen, waveDuration, noteDuration);
            envelope.audioBufferSourceNode = this.audioContext.createBufferSource();
            envelope.audioBufferSourceNode.playbackRate.setValueAtTime(playbackRate, 0);
            var newWhen = startWhen;
            for (var ii = 0; ii < slides.length; ii++) {
                var nextPitch = pitch + slides[ii].delta;
                var newPlaybackRate = 1.0 * Math.pow(2, (100.0 * nextPitch - baseDetune) / 1200.0);
                var newWhen = newWhen + slides[ii].duration;
                envelope.audioBufferSourceNode.playbackRate.linearRampToValueAtTime(newPlaybackRate, newWhen);
            }
            envelope.audioBufferSourceNode.buffer = zone.buffer;
            if (loop) {
                envelope.audioBufferSourceNode.loop = true;
                envelope.audioBufferSourceNode.loopStart = zone.loopStart / zone.sampleRate + ((zone.delay) ? zone.delay : 0);
                envelope.audioBufferSourceNode.loopEnd = zone.loopEnd / zone.sampleRate + ((zone.delay) ? zone.delay : 0);
            }
            else {
                envelope.audioBufferSourceNode.loop = false;
            }
            envelope.audioBufferSourceNode.connect(envelope);
            envelope.audioBufferSourceNode.start(startWhen, zone.delay);
            envelope.audioBufferSourceNode.stop(startWhen + waveDuration);
            envelope.when = startWhen;
            envelope.duration = waveDuration;
            envelope.pitch = pitch;
            envelope.preset = preset;
            return envelope;
        }
        else {
            return null;
        }
    }
    ;
    cancelQueue() {
        for (var i = 0; i < this.envelopes.length; i++) {
            var e = this.envelopes[i];
            e.gain.cancelScheduledValues(0);
            e.gain.setValueAtTime(this.nearZero, this.audioContext.currentTime);
            e.when = -1;
            try {
                if (e.audioBufferSourceNode)
                    e.audioBufferSourceNode.disconnect();
            }
            catch (ex) {
                console.log(ex);
            }
        }
    }
    instrumentInfo(n) {
        var key = WAFMIDIPresetURLs[n];
        if (!(key)) {
            console.log('not found instrument definition for', n);
        }
        return {
            variable: '_tone_' + key,
            url: 'https://surikov.github.io/webaudiofontdata/sound/' + key + '.js'
        };
    }
    ;
}
function testPluginWAF() {
    return new PerformerPluginWAF();
}
//# sourceMappingURL=testwaf.js.map